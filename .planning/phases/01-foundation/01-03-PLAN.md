---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/auth/auth.service.ts
  - src/auth/auth.controller.ts
  - src/auth/auth.module.ts
  - src/auth/strategies/jwt.strategy.ts
  - src/auth/strategies/refresh-token.strategy.ts
  - src/auth/guards/jwt-auth.guard.ts
  - src/auth/guards/refresh-token.guard.ts
  - src/auth/guards/roles.guard.ts
  - src/auth/dto/register.dto.ts
  - src/auth/dto/login.dto.ts
  - src/auth/dto/forgot-password.dto.ts
  - src/auth/dto/reset-password.dto.ts
  - src/auth/decorators/current-user.decorator.ts
autonomous: true

must_haves:
  truths:
    - "POST /auth/register creates a user with argon2id-hashed password and returns access + refresh tokens"
    - "POST /auth/login validates credentials and returns access + refresh tokens"
    - "POST /auth/refresh accepts a valid refresh token and returns new token pair (rotation)"
    - "POST /auth/logout nullifies the refresh token hash, making the old refresh token invalid"
    - "POST /auth/forgot-password sends a password reset email (or logs it in dev mode)"
    - "POST /auth/reset-password accepts a valid reset token and sets a new argon2id-hashed password"
    - "Access tokens expire in 15 minutes; refresh tokens expire in 7 days"
    - "Using an invalidated refresh token returns 403 Forbidden"
  artifacts:
    - path: "src/auth/auth.service.ts"
      provides: "Auth service with argon2id hashing, dual JWT, refresh rotation, password reset"
      contains: "argon2"
    - path: "src/auth/auth.controller.ts"
      provides: "Auth controller with register, login, logout, refresh, forgot-password, reset-password endpoints"
      exports: ["AuthController"]
    - path: "src/auth/strategies/refresh-token.strategy.ts"
      provides: "Passport strategy for refresh token validation"
      contains: "jwt-refresh"
    - path: "src/auth/dto/forgot-password.dto.ts"
      provides: "DTO for forgot-password endpoint"
    - path: "src/auth/dto/reset-password.dto.ts"
      provides: "DTO for reset-password endpoint"
  key_links:
    - from: "src/auth/auth.service.ts"
      to: "argon2"
      via: "argon2.hash() and argon2.verify()"
      pattern: "argon2\\.(hash|verify)"
    - from: "src/auth/auth.service.ts"
      to: "prisma user model"
      via: "prisma.user.update for refreshTokenHash"
      pattern: "refreshTokenHash"
    - from: "src/auth/auth.module.ts"
      to: "JwtModule"
      via: "registerAsync with access secret (not single JWT_SECRET)"
      pattern: "JWT_ACCESS_SECRET"
    - from: "src/auth/auth.controller.ts"
      to: "src/auth/guards/refresh-token.guard.ts"
      via: "UseGuards on /auth/refresh endpoint"
      pattern: "RefreshTokenGuard"
---

<objective>
Rewrite the auth module from bcrypt + single JWT to argon2id + dual JWT (access 15m + refresh 7d) with refresh token rotation, logout, and password reset via email.

Purpose: Replaces the insecure auth implementation (bcrypt, single 24h JWT, no logout, no refresh, no password reset) with production-ready auth that satisfies AUTH-01 through AUTH-04.

Output: Complete auth API with 6 endpoints (register, login, logout, refresh, forgot-password, reset-password), argon2id password hashing, dual JWT with separate secrets, refresh token rotation, and password reset flow.
</objective>

<execution_context>
@C:\Users\33641\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\33641\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/PHASE1-RESEARCH.md
@src/auth/auth.service.ts
@src/auth/auth.controller.ts
@src/auth/auth.module.ts
@src/auth/strategies/jwt.strategy.ts
@src/auth/guards/jwt-auth.guard.ts
@src/auth/dto/register.dto.ts
@src/auth/dto/login.dto.ts
@src/auth/decorators/current-user.decorator.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite auth service and module for argon2id + dual JWT</name>
  <files>
    src/auth/auth.service.ts
    src/auth/auth.module.ts
    src/auth/strategies/jwt.strategy.ts
    src/auth/strategies/refresh-token.strategy.ts
    src/auth/guards/jwt-auth.guard.ts
    src/auth/guards/refresh-token.guard.ts
    src/auth/decorators/current-user.decorator.ts
  </files>
  <action>
    1. REWRITE `src/auth/auth.service.ts`:
       - Replace `import * as bcrypt from 'bcrypt'` with `import * as argon2 from 'argon2'`
       - Replace `bcrypt.hash(password, 10)` with `argon2.hash(password, { type: argon2.argon2id, memoryCost: 65536, timeCost: 3, parallelism: 4 })`
       - Replace `bcrypt.compare(password, hash)` with `argon2.verify(hash, password)`
       - Add `getTokens(userId, email, role)` method that generates BOTH access (15m, JWT_ACCESS_SECRET) and refresh (7d, JWT_REFRESH_SECRET) tokens using separate `this.jwtService.signAsync()` calls with explicit secret/expiresIn
       - Add `updateRefreshToken(userId, refreshToken)` method that hashes the refresh token with argon2 and stores in `user.refreshTokenHash`
       - Add `refreshTokens(userId, refreshToken)` method that:
         - Loads user, checks refreshTokenHash exists
         - Verifies refresh token against hash with argon2.verify
         - Generates new token pair, updates stored hash (rotation)
         - Returns new tokens
       - Add `logout(userId)` method that sets `refreshTokenHash: null`
       - Add `forgotPassword(email)` method that:
         - Finds user by email (return silently if not found -- don't reveal existence)
         - Generates a signed JWT with { sub: userId, email } using JWT_ACCESS_SECRET with 1h expiry
         - In development: logs the reset URL to console
         - In production: sends email via Resend with reset link to `${FRONTEND_URL}/reset-password?token=${token}`
       - Add `resetPassword(token, newPassword)` method that:
         - Verifies the JWT token
         - Hashes new password with argon2
         - Updates user's passwordHash
         - Sets refreshTokenHash to null (force re-login)
       - Update `register()` to call `getTokens()` and `updateRefreshToken()`, return both tokens
       - Update `login()` to call `getTokens()` and `updateRefreshToken()`, return both tokens
       - Inject ConfigService for accessing JWT_ACCESS_SECRET, JWT_REFRESH_SECRET, FRONTEND_URL

    2. REWRITE `src/auth/auth.module.ts`:
       - Change JwtModule.registerAsync to NOT specify a default secret (tokens signed per-call with explicit secrets)
       - Or register with the access secret as default: `secret: configService.get('JWT_ACCESS_SECRET'), signOptions: { expiresIn: '15m' }`
       - Add RefreshTokenStrategy to providers
       - Remove LocalStrategy (we'll validate in service directly, not via passport-local)
       - Import ConfigModule if needed

    3. RENAME `src/auth/strategies/jwt.strategy.ts` to use JWT_ACCESS_SECRET:
       - Constructor reads `configService.get('JWT_ACCESS_SECRET')` instead of `configService.get('JWT_SECRET')`
       - Strategy name remains 'jwt' (for the AccessTokenGuard)

    4. CREATE `src/auth/strategies/refresh-token.strategy.ts`:
       - PassportStrategy(Strategy, 'jwt-refresh')
       - Uses JWT_REFRESH_SECRET
       - passReqToCallback: true
       - validate() extracts the raw refresh token from Authorization header and returns it with payload
       - Follow exact pattern from PHASE1-RESEARCH.md

    5. UPDATE `src/auth/guards/jwt-auth.guard.ts`:
       - Ensure it uses AuthGuard('jwt') -- this should already be correct

    6. CREATE `src/auth/guards/refresh-token.guard.ts`:
       - AuthGuard('jwt-refresh')

    7. UPDATE `src/auth/decorators/current-user.decorator.ts` if needed:
       - Ensure it extracts user from request correctly for both strategies

    IMPORTANT: Do NOT remove `src/auth/strategies/local.strategy.ts` or `src/auth/guards/local-auth.guard.ts` files yet -- just don't import them in the module. They can be cleaned up later.
  </action>
  <verify>
    - `npm run build` succeeds
    - `grep -r "bcrypt" src/auth/` returns no results (bcrypt fully removed from auth)
    - `grep -c "argon2" src/auth/auth.service.ts` returns >= 3 (hash, verify calls)
    - `grep "JWT_ACCESS_SECRET" src/auth/strategies/jwt.strategy.ts` confirms new secret name
    - `ls src/auth/strategies/refresh-token.strategy.ts` exists
    - `ls src/auth/guards/refresh-token.guard.ts` exists
  </verify>
  <done>Auth service uses argon2id, generates dual JWT tokens, supports refresh rotation, logout, and password reset. Two Passport strategies registered for access and refresh tokens.</done>
</task>

<task type="auto">
  <name>Task 2: Update auth controller with all 6 endpoints and DTOs</name>
  <files>
    src/auth/auth.controller.ts
    src/auth/dto/register.dto.ts
    src/auth/dto/login.dto.ts
    src/auth/dto/forgot-password.dto.ts
    src/auth/dto/reset-password.dto.ts
  </files>
  <action>
    1. UPDATE `src/auth/dto/register.dto.ts`:
       - @IsEmail() email
       - @IsString() @MinLength(8) @MaxLength(128) password
       - @IsString() @MinLength(2) @MaxLength(100) name
       - Add @ApiProperty() decorators for Swagger (or rely on CLI plugin to infer from class-validator)

    2. UPDATE `src/auth/dto/login.dto.ts`:
       - @IsEmail() email
       - @IsString() password

    3. CREATE `src/auth/dto/forgot-password.dto.ts`:
       - @IsEmail() email

    4. CREATE `src/auth/dto/reset-password.dto.ts`:
       - @IsString() token
       - @IsString() @MinLength(8) @MaxLength(128) newPassword

    5. REWRITE `src/auth/auth.controller.ts` with 6 endpoints:
       ```
       POST /auth/register     -- @Body() RegisterDto -> { accessToken, refreshToken, user }
       POST /auth/login        -- @Body() LoginDto -> { accessToken, refreshToken, user }
                                   (validate in service, not via LocalAuthGuard)
       POST /auth/logout       -- @UseGuards(JwtAuthGuard) -> { message: 'Logged out' }
                                   Calls authService.logout(user.sub)
       POST /auth/refresh      -- @UseGuards(RefreshTokenGuard) -> { accessToken, refreshToken }
                                   Extracts userId and refreshToken from request.user
                                   Calls authService.refreshTokens(userId, refreshToken)
       POST /auth/forgot-password -- @Body() ForgotPasswordDto -> { message: 'If email exists...' }
                                      Always returns 200 (don't reveal email existence)
       POST /auth/reset-password  -- @Body() ResetPasswordDto -> { message: 'Password reset' }
       GET  /auth/profile      -- @UseGuards(JwtAuthGuard) -> user from token
       ```

    6. Add Swagger decorators to the controller:
       - @ApiTags('auth') on the controller class
       - @ApiOperation() on each endpoint
       - @ApiBearerAuth() on protected endpoints (logout, refresh, profile)

    7. Apply rate limiting to sensitive endpoints:
       - @Throttle({ short: { limit: 1, ttl: 1000 } }) on /auth/login
       - @Throttle({ short: { limit: 1, ttl: 1000 } }) on /auth/forgot-password
       - These prevent brute-force attacks

    8. Verify the full auth flow works:
       ```bash
       # Start the app
       npm run start:dev &

       # Register
       curl -X POST http://localhost:3000/auth/register \
         -H "Content-Type: application/json" \
         -d '{"email":"test@test.com","password":"password123","name":"Test"}'

       # Login
       curl -X POST http://localhost:3000/auth/login \
         -H "Content-Type: application/json" \
         -d '{"email":"test@test.com","password":"password123"}'

       # Use access token for profile
       curl http://localhost:3000/auth/profile \
         -H "Authorization: Bearer <access_token>"

       # Refresh
       curl -X POST http://localhost:3000/auth/refresh \
         -H "Authorization: Bearer <refresh_token>"

       # Logout
       curl -X POST http://localhost:3000/auth/logout \
         -H "Authorization: Bearer <access_token>"
       ```
  </action>
  <verify>
    - `npm run build` succeeds
    - Register returns accessToken + refreshToken + user object
    - Login returns accessToken + refreshToken + user object
    - Profile with valid access token returns user data
    - Refresh with valid refresh token returns new token pair
    - Logout returns 200, subsequent refresh with old token returns 403
    - Forgot-password returns 200 regardless of email existence
    - Reset-password with valid token and new password returns 200
  </verify>
  <done>All 6 auth endpoints working: register, login, logout, refresh, forgot-password, reset-password. DTOs validated, Swagger documented, rate-limited on sensitive endpoints.</done>
</task>

</tasks>

<verification>
1. `npm run build` -- no TypeScript errors
2. Full auth flow test (register -> login -> profile -> refresh -> logout -> verify token invalid)
3. `curl -X POST http://localhost:3000/auth/register -H "Content-Type: application/json" -d '{"email":"test@test.com","password":"pass123456","name":"Test"}'` -- returns tokens
4. Password reset flow: forgot-password -> check console for token (dev mode) -> reset-password with token
5. Rate limiting: rapid login attempts get 429
6. Swagger at /api/docs shows all auth endpoints documented
</verification>

<success_criteria>
- AUTH-01: Sign up with argon2id hashing, returns access + refresh tokens
- AUTH-02: Login with dual JWT (access 15m, refresh 7d), refresh rotation works
- AUTH-03: Logout invalidates refresh token (nullifies hash in DB)
- AUTH-04: Password reset via signed JWT link (console log in dev, email in prod)
- No bcrypt anywhere in auth code
- Dual JWT secrets: JWT_ACCESS_SECRET and JWT_REFRESH_SECRET
- Sensitive endpoints rate-limited
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
