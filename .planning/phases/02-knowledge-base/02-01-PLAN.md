---
phase: 02-knowledge-base
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/api/prisma/schema.prisma
  - apps/api/src/knowledge-base/knowledge-base.module.ts
  - apps/api/src/knowledge-base/knowledge-base.controller.ts
  - apps/api/src/knowledge-base/knowledge-base.service.ts
  - apps/api/src/knowledge-base/storage/s3.service.ts
  - apps/api/src/knowledge-base/dto/upload-document.dto.ts
  - apps/api/src/knowledge-base/dto/create-text-source.dto.ts
  - apps/api/src/knowledge-base/dto/document-response.dto.ts
  - apps/api/src/app.module.ts
  - apps/api/src/config/env.validation.ts
  - apps/api/src/main.ts
autonomous: true
user_setup:
  - service: openai
    why: "Embedding generation for document chunks (used in Plan 03)"
    env_vars:
      - name: OPENAI_API_KEY
        source: "https://platform.openai.com/api-keys -> Create new secret key"

must_haves:
  truths:
    - "User can upload a PDF, DOCX, MD, or TXT file and receive a document record with status UPLOADED"
    - "User can paste raw text and it appears as a KB source with status UPLOADED"
    - "User can paste a URL and it appears as a KB source with status UPLOADED"
    - "User can list their documents with status tracking"
    - "User can delete a document from their knowledge base"
    - "Uploaded files are stored in MinIO S3, not local disk"
    - "Document status shows UPLOADED immediately after creation"
  artifacts:
    - path: "apps/api/prisma/schema.prisma"
      provides: "Document and DocumentChunk models, DocumentStatus and DocumentSourceType enums"
      contains: "model Document"
    - path: "apps/api/src/knowledge-base/knowledge-base.controller.ts"
      provides: "Upload, text/URL ingestion, list, get, delete endpoints"
      exports: ["KnowledgeBaseController"]
    - path: "apps/api/src/knowledge-base/knowledge-base.service.ts"
      provides: "Business logic for document CRUD and file upload orchestration"
      exports: ["KnowledgeBaseService"]
    - path: "apps/api/src/knowledge-base/storage/s3.service.ts"
      provides: "MinIO/S3 upload, download, presigned URLs, bucket auto-creation"
      exports: ["S3Service"]
  key_links:
    - from: "apps/api/src/knowledge-base/knowledge-base.controller.ts"
      to: "apps/api/src/knowledge-base/knowledge-base.service.ts"
      via: "constructor injection"
      pattern: "KnowledgeBaseService"
    - from: "apps/api/src/knowledge-base/knowledge-base.service.ts"
      to: "apps/api/src/knowledge-base/storage/s3.service.ts"
      via: "constructor injection"
      pattern: "S3Service"
    - from: "apps/api/src/knowledge-base/knowledge-base.controller.ts"
      to: "Multer FileInterceptor"
      via: "@UseInterceptors(FileInterceptor)"
      pattern: "FileInterceptor.*file"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/knowledge-base/knowledge-base.module.ts"
      via: "imports array"
      pattern: "KnowledgeBaseModule"
---

<objective>
Create the Knowledge Base foundation: Prisma schema (Document + DocumentChunk models), S3 storage service with MinIO bucket auto-creation, file upload endpoint (PDF/DOCX/MD/TXT via Multer), text/URL ingestion endpoints, and document CRUD (list, get, delete). Also install all backend dependencies for the entire Phase 2, rename DeckPilot to Pitchable in main.ts Swagger title, and add S3/OpenAI env vars.

Purpose: This is the data layer and API surface that all other Phase 2 plans build on. Without the schema, S3 storage, and CRUD endpoints, parsing (Plan 02), embedding (Plan 03), and frontend (Plan 04) have nothing to connect to.

Output: Working API endpoints for document upload/ingestion/CRUD, S3 storage with auto-bucket, and Prisma schema with Document + DocumentChunk models.
</objective>

<execution_context>
@C:\Users\33641\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\33641\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:\Users\33641\projects\slide-saas\.planning\PROJECT.md
@C:\Users\33641\projects\slide-saas\.planning\ROADMAP.md
@C:\Users\33641\projects\slide-saas\.planning\STATE.md
@C:\Users\33641\projects\slide-saas\.planning\phases\02-knowledge-base\02-RESEARCH.md

Key existing files to reference:
@C:\Users\33641\projects\slide-saas\apps\api\src\app.module.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\main.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\images\images.module.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\images\images.controller.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\images\image-generation.processor.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\auth\guards\jwt-auth.guard.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\auth\decorators\current-user.decorator.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\prisma\prisma.service.ts
@C:\Users\33641\projects\slide-saas\apps\api\src\config\env.validation.ts
@C:\Users\33641\projects\slide-saas\apps\api\prisma\schema.prisma
@C:\Users\33641\projects\slide-saas\docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, update schema, update env config, rename DeckPilot</name>
  <files>
    apps/api/prisma/schema.prisma
    apps/api/src/config/env.validation.ts
    apps/api/src/main.ts
    apps/api/package.json
  </files>
  <action>
**Step 1: Install all Phase 2 backend dependencies** (run from project root):
```bash
cd apps/api && pnpm add @aws-sdk/client-s3 @aws-sdk/s3-request-presigner pdf-parse mammoth marked openai pgvector @mozilla/readability jsdom mime-types
cd apps/api && pnpm add -D @types/multer @types/jsdom
```

**Step 2: Update Prisma schema** (`apps/api/prisma/schema.prisma`).

Add these two new enums AFTER the existing `JobStatus` enum:
```prisma
enum DocumentStatus {
  UPLOADED
  PARSING
  EMBEDDING
  READY
  ERROR
}

enum DocumentSourceType {
  FILE
  TEXT
  URL
}
```

Add these two new models AFTER the existing `ImageJob` model:
```prisma
model Document {
  id           String             @id @default(uuid()) @db.Uuid
  userId       String             @db.Uuid
  title        String
  sourceType   DocumentSourceType
  mimeType     String?
  fileSize     Int?
  s3Key        String?
  sourceUrl    String?
  status       DocumentStatus     @default(UPLOADED)
  chunkCount   Int                @default(0)
  errorMessage String?
  processedAt  DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks DocumentChunk[]

  @@index([userId])
  @@index([status])
}

model DocumentChunk {
  id           String   @id @default(uuid()) @db.Uuid
  documentId   String   @db.Uuid
  content      String   @db.Text
  heading      String?
  headingLevel Int      @default(0)
  chunkIndex   Int
  embedding    Unsupported("vector(1536)")?
  metadata     Json     @default("{}")
  createdAt    DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
}
```

Add `documents Document[]` relation to the existing `User` model (after the `creditTransactions CreditTransaction[]` line):
```prisma
  documents          Document[]
```

**Step 3: Run Prisma migration.**
Use `prisma migrate dev --create-only` to create the migration file, then manually edit it to add the HNSW vector index. Then apply.

```bash
cd apps/api && npx prisma migrate dev --create-only --name add_knowledge_base
```

After the migration SQL file is created, APPEND this line at the end of the migration SQL file (find it in `prisma/migrations/<timestamp>_add_knowledge_base/migration.sql`):
```sql
-- HNSW index for fast cosine similarity search
CREATE INDEX "DocumentChunk_embedding_idx" ON "DocumentChunk"
  USING hnsw ("embedding" vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);
```

Then apply:
```bash
cd apps/api && npx prisma migrate dev
```

Then regenerate the Prisma client:
```bash
cd apps/api && npx prisma generate
```

**Step 4: Update env.validation.ts** (`apps/api/src/config/env.validation.ts`).

Add these optional env vars to the `EnvironmentVariables` class:
```typescript
@IsOptional()
@IsString()
S3_ENDPOINT?: string = 'http://localhost:9000';

@IsOptional()
@IsString()
S3_REGION?: string = 'us-east-1';

@IsOptional()
@IsString()
S3_ACCESS_KEY?: string = 'minioadmin';

@IsOptional()
@IsString()
S3_SECRET_KEY?: string = 'minioadmin';

@IsOptional()
@IsString()
S3_BUCKET?: string = 'pitchable-documents';

@IsOptional()
@IsString()
OPENAI_API_KEY?: string;
```

**Step 5: Rename DeckPilot to Pitchable** in `apps/api/src/main.ts`.

Change line: `.setTitle('DeckPilot API')` to `.setTitle('Pitchable API')`
  </action>
  <verify>
Run `cd C:/Users/33641/projects/slide-saas/apps/api && npx prisma validate` -- should pass.
Run `cd C:/Users/33641/projects/slide-saas/apps/api && npx tsc --noEmit` -- should compile without errors.
Verify the migration SQL file contains the HNSW index creation.
Verify `generated/prisma` contains the new `Document` and `DocumentChunk` types.
  </verify>
  <done>
Prisma schema has 10 models (8 existing + Document + DocumentChunk), 10 enums (8 existing + DocumentStatus + DocumentSourceType). Migration applied. HNSW vector index created. All Phase 2 backend deps installed. Env validation includes S3 and OpenAI vars. Swagger title says "Pitchable API".
  </done>
</task>

<task type="auto">
  <name>Task 2: S3 service, DTOs, KB service, controller, and module wiring</name>
  <files>
    apps/api/src/knowledge-base/storage/s3.service.ts
    apps/api/src/knowledge-base/dto/upload-document.dto.ts
    apps/api/src/knowledge-base/dto/create-text-source.dto.ts
    apps/api/src/knowledge-base/dto/document-response.dto.ts
    apps/api/src/knowledge-base/knowledge-base.service.ts
    apps/api/src/knowledge-base/knowledge-base.controller.ts
    apps/api/src/knowledge-base/knowledge-base.module.ts
    apps/api/src/app.module.ts
  </files>
  <action>
**Step 1: Create S3 service** (`apps/api/src/knowledge-base/storage/s3.service.ts`):
```typescript
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  HeadBucketCommand,
  CreateBucketCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

@Injectable()
export class S3Service implements OnModuleInit {
  private readonly logger = new Logger(S3Service.name);
  private readonly s3: S3Client;
  private readonly bucket: string;

  constructor(private readonly config: ConfigService) {
    this.bucket = config.get<string>('S3_BUCKET', 'pitchable-documents');
    this.s3 = new S3Client({
      endpoint: config.get<string>('S3_ENDPOINT', 'http://localhost:9000'),
      region: config.get<string>('S3_REGION', 'us-east-1'),
      credentials: {
        accessKeyId: config.get<string>('S3_ACCESS_KEY', 'minioadmin'),
        secretAccessKey: config.get<string>('S3_SECRET_KEY', 'minioadmin'),
      },
      forcePathStyle: true, // REQUIRED for MinIO
    });
  }

  async onModuleInit(): Promise<void> {
    try {
      await this.s3.send(new HeadBucketCommand({ Bucket: this.bucket }));
      this.logger.log(`S3 bucket "${this.bucket}" exists`);
    } catch {
      this.logger.log(`Creating S3 bucket "${this.bucket}"...`);
      await this.s3.send(new CreateBucketCommand({ Bucket: this.bucket }));
      this.logger.log(`S3 bucket "${this.bucket}" created`);
    }
  }

  async upload(key: string, body: Buffer, contentType: string): Promise<string> {
    await this.s3.send(
      new PutObjectCommand({
        Bucket: this.bucket,
        Key: key,
        Body: body,
        ContentType: contentType,
      }),
    );
    return key;
  }

  async getBuffer(key: string): Promise<Buffer> {
    const response = await this.s3.send(
      new GetObjectCommand({ Bucket: this.bucket, Key: key }),
    );
    const stream = response.Body;
    if (!stream) throw new Error(`Empty response for key: ${key}`);
    // Convert readable stream to buffer
    const chunks: Uint8Array[] = [];
    for await (const chunk of stream as AsyncIterable<Uint8Array>) {
      chunks.push(chunk);
    }
    return Buffer.concat(chunks);
  }

  async getSignedDownloadUrl(key: string, expiresIn = 3600): Promise<string> {
    return getSignedUrl(
      this.s3,
      new GetObjectCommand({ Bucket: this.bucket, Key: key }),
      { expiresIn },
    );
  }

  async delete(key: string): Promise<void> {
    await this.s3.send(
      new DeleteObjectCommand({ Bucket: this.bucket, Key: key }),
    );
  }
}
```

**Step 2: Create DTOs.**

`apps/api/src/knowledge-base/dto/upload-document.dto.ts`:
```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsOptional, MaxLength } from 'class-validator';

export class UploadDocumentDto {
  @ApiPropertyOptional({ description: 'Custom title for the document' })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  title?: string;
}
```

`apps/api/src/knowledge-base/dto/create-text-source.dto.ts`:
```typescript
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { IsString, IsOptional, IsUrl, MaxLength, MinLength, IsEnum } from 'class-validator';

export class CreateTextSourceDto {
  @ApiProperty({ description: 'Raw text content to add to knowledge base' })
  @IsString()
  @MinLength(1)
  @MaxLength(100000)
  content: string;

  @ApiPropertyOptional({ description: 'Title for the text source' })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  title?: string;
}

export class CreateUrlSourceDto {
  @ApiProperty({ description: 'URL to fetch and add to knowledge base' })
  @IsUrl()
  url: string;

  @ApiPropertyOptional({ description: 'Title for the URL source' })
  @IsOptional()
  @IsString()
  @MaxLength(255)
  title?: string;
}
```

`apps/api/src/knowledge-base/dto/document-response.dto.ts`:
```typescript
import { ApiProperty } from '@nestjs/swagger';

export class DocumentResponseDto {
  @ApiProperty() id: string;
  @ApiProperty() title: string;
  @ApiProperty() sourceType: string;
  @ApiProperty({ required: false }) mimeType: string | null;
  @ApiProperty({ required: false }) fileSize: number | null;
  @ApiProperty() status: string;
  @ApiProperty() chunkCount: number;
  @ApiProperty({ required: false }) errorMessage: string | null;
  @ApiProperty({ required: false }) sourceUrl: string | null;
  @ApiProperty({ required: false }) processedAt: Date | null;
  @ApiProperty() createdAt: Date;
  @ApiProperty() updatedAt: Date;
}
```

**Step 3: Create knowledge-base service** (`apps/api/src/knowledge-base/knowledge-base.service.ts`):
```typescript
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bullmq';
import { Queue } from 'bullmq';
import { PrismaService } from '../prisma/prisma.service.js';
import { S3Service } from './storage/s3.service.js';
import { DocumentSourceType, DocumentStatus } from '../../generated/prisma/enums.js';
import { randomUUID } from 'node:crypto';

export interface DocumentProcessingJobData {
  documentId: string;
  userId: string;
  sourceType: 'FILE' | 'TEXT' | 'URL';
  mimeType?: string;
  s3Key?: string;
  rawText?: string;
  url?: string;
}

@Injectable()
export class KnowledgeBaseService {
  private readonly logger = new Logger(KnowledgeBaseService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly s3: S3Service,
    @InjectQueue('document-processing') private readonly docQueue: Queue,
  ) {}

  async uploadFile(
    userId: string,
    file: Express.Multer.File,
    customTitle?: string,
  ) {
    // 1. Upload file to S3
    const s3Key = `documents/${userId}/${randomUUID()}/${file.originalname}`;
    await this.s3.upload(s3Key, file.buffer, file.mimetype);

    // 2. Create Document record
    const title = customTitle || file.originalname;
    const document = await this.prisma.document.create({
      data: {
        userId,
        title,
        sourceType: DocumentSourceType.FILE,
        mimeType: file.mimetype,
        fileSize: file.size,
        s3Key,
        status: DocumentStatus.UPLOADED,
      },
    });

    // 3. Enqueue for processing
    await this.docQueue.add('process-document', {
      documentId: document.id,
      userId,
      sourceType: 'FILE',
      mimeType: file.mimetype,
      s3Key,
    } satisfies DocumentProcessingJobData);

    this.logger.log(`Document ${document.id} uploaded and queued for processing`);
    return document;
  }

  async createTextSource(userId: string, content: string, customTitle?: string) {
    const title = customTitle || `Text source - ${new Date().toISOString().slice(0, 10)}`;
    const document = await this.prisma.document.create({
      data: {
        userId,
        title,
        sourceType: DocumentSourceType.TEXT,
        fileSize: Buffer.byteLength(content, 'utf-8'),
        status: DocumentStatus.UPLOADED,
      },
    });

    await this.docQueue.add('process-document', {
      documentId: document.id,
      userId,
      sourceType: 'TEXT',
      rawText: content,
    } satisfies DocumentProcessingJobData);

    this.logger.log(`Text source ${document.id} created and queued`);
    return document;
  }

  async createUrlSource(userId: string, url: string, customTitle?: string) {
    const title = customTitle || url;
    const document = await this.prisma.document.create({
      data: {
        userId,
        title,
        sourceType: DocumentSourceType.URL,
        sourceUrl: url,
        status: DocumentStatus.UPLOADED,
      },
    });

    await this.docQueue.add('process-document', {
      documentId: document.id,
      userId,
      sourceType: 'URL',
      url,
    } satisfies DocumentProcessingJobData);

    this.logger.log(`URL source ${document.id} created and queued`);
    return document;
  }

  async listDocuments(userId: string) {
    return this.prisma.document.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        title: true,
        sourceType: true,
        mimeType: true,
        fileSize: true,
        status: true,
        chunkCount: true,
        errorMessage: true,
        sourceUrl: true,
        processedAt: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  async getDocument(userId: string, documentId: string) {
    const doc = await this.prisma.document.findFirst({
      where: { id: documentId, userId },
    });
    if (!doc) throw new NotFoundException('Document not found');
    return doc;
  }

  async deleteDocument(userId: string, documentId: string) {
    const doc = await this.prisma.document.findFirst({
      where: { id: documentId, userId },
    });
    if (!doc) throw new NotFoundException('Document not found');

    // Delete S3 object if exists
    if (doc.s3Key) {
      try {
        await this.s3.delete(doc.s3Key);
      } catch (error) {
        this.logger.warn(`Failed to delete S3 object ${doc.s3Key}: ${error}`);
      }
    }

    // Cascade deletes DocumentChunks via Prisma relation
    await this.prisma.document.delete({ where: { id: documentId } });
    return { message: 'Document deleted' };
  }
}
```

**Step 4: Create controller** (`apps/api/src/knowledge-base/knowledge-base.controller.ts`):
```typescript
import {
  Controller,
  Get,
  Post,
  Delete,
  Param,
  Body,
  UseGuards,
  UseInterceptors,
  UploadedFile,
  ParseFilePipe,
  MaxFileSizeValidator,
  FileTypeValidator,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { ApiTags, ApiBearerAuth, ApiConsumes, ApiBody } from '@nestjs/swagger';
import * as multer from 'multer';
import { KnowledgeBaseService } from './knowledge-base.service.js';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard.js';
import { CurrentUser } from '../auth/decorators/current-user.decorator.js';
import type { RequestUser } from '../auth/decorators/current-user.decorator.js';
import { UploadDocumentDto } from './dto/upload-document.dto.js';
import { CreateTextSourceDto, CreateUrlSourceDto } from './dto/create-text-source.dto.js';

@ApiTags('knowledge-base')
@ApiBearerAuth()
@Controller('knowledge-base')
@UseGuards(JwtAuthGuard)
export class KnowledgeBaseController {
  constructor(private readonly kbService: KnowledgeBaseService) {}

  @Post('upload')
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: { type: 'string', format: 'binary' },
        title: { type: 'string' },
      },
    },
  })
  @UseInterceptors(
    FileInterceptor('file', {
      storage: multer.memoryStorage(),
      limits: { fileSize: 20 * 1024 * 1024 }, // 20MB
    }),
  )
  async uploadDocument(
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({ maxSize: 20 * 1024 * 1024 }),
          new FileTypeValidator({
            fileType: /(pdf|vnd\.openxmlformats-officedocument\.wordprocessingml\.document|plain|markdown|text)/,
          }),
        ],
      }),
    )
    file: Express.Multer.File,
    @CurrentUser() user: RequestUser,
    @Body() dto: UploadDocumentDto,
  ) {
    return this.kbService.uploadFile(user.userId, file, dto.title);
  }

  @Post('text')
  async createTextSource(
    @CurrentUser() user: RequestUser,
    @Body() dto: CreateTextSourceDto,
  ) {
    return this.kbService.createTextSource(user.userId, dto.content, dto.title);
  }

  @Post('url')
  async createUrlSource(
    @CurrentUser() user: RequestUser,
    @Body() dto: CreateUrlSourceDto,
  ) {
    return this.kbService.createUrlSource(user.userId, dto.url, dto.title);
  }

  @Get('documents')
  async listDocuments(@CurrentUser() user: RequestUser) {
    return this.kbService.listDocuments(user.userId);
  }

  @Get('documents/:id')
  async getDocument(
    @CurrentUser() user: RequestUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.kbService.getDocument(user.userId, id);
  }

  @Delete('documents/:id')
  @HttpCode(HttpStatus.OK)
  async deleteDocument(
    @CurrentUser() user: RequestUser,
    @Param('id', ParseUUIDPipe) id: string,
  ) {
    return this.kbService.deleteDocument(user.userId, id);
  }
}
```

IMPORTANT: The import `import * as multer from 'multer';` may need to be `import multer from 'multer';` depending on the project's ESM configuration. Check the `tsconfig.json` -- if `"module": "NodeNext"` or `"esModuleInterop": true`, use `import multer from 'multer';`. If the import fails at compile time, switch to the other form.

**Step 5: Create module** (`apps/api/src/knowledge-base/knowledge-base.module.ts`):
```typescript
import { Module } from '@nestjs/common';
import { BullModule } from '@nestjs/bullmq';
import { ConfigModule } from '@nestjs/config';
import { PrismaModule } from '../prisma/prisma.module.js';
import { KnowledgeBaseController } from './knowledge-base.controller.js';
import { KnowledgeBaseService } from './knowledge-base.service.js';
import { S3Service } from './storage/s3.service.js';

@Module({
  imports: [
    PrismaModule,
    ConfigModule,
    BullModule.registerQueue({ name: 'document-processing' }),
  ],
  controllers: [KnowledgeBaseController],
  providers: [KnowledgeBaseService, S3Service],
  exports: [KnowledgeBaseService, S3Service],
})
export class KnowledgeBaseModule {}
```

**Step 6: Register module in AppModule** (`apps/api/src/app.module.ts`).

Add import at top:
```typescript
import { KnowledgeBaseModule } from './knowledge-base/knowledge-base.module.js';
```

Add `KnowledgeBaseModule` to the imports array, after `ExportsModule` and before `HealthModule`.
  </action>
  <verify>
Run `cd C:/Users/33641/projects/slide-saas/apps/api && npx tsc --noEmit` -- should compile without errors.
Verify the `knowledge-base/` directory has 7 files: module, controller, service, s3.service, 3 DTOs.
Verify `app.module.ts` imports `KnowledgeBaseModule`.
  </verify>
  <done>
- POST /knowledge-base/upload accepts multipart file upload (PDF/DOCX/MD/TXT, max 20MB), stores in MinIO, creates Document record, enqueues processing job
- POST /knowledge-base/text accepts raw text, creates Document record, enqueues processing job
- POST /knowledge-base/url accepts URL, creates Document record, enqueues processing job
- GET /knowledge-base/documents lists user's documents with status
- GET /knowledge-base/documents/:id gets single document detail
- DELETE /knowledge-base/documents/:id deletes document + S3 object + chunks (cascade)
- S3Service auto-creates bucket on startup
- BullMQ document-processing queue registered but no processor yet (Plan 02)
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes (schema is valid)
2. `npx tsc --noEmit` passes (TypeScript compiles)
3. All 7 new files exist under `apps/api/src/knowledge-base/`
4. `app.module.ts` contains `KnowledgeBaseModule` import
5. `main.ts` Swagger title says "Pitchable API"
6. `env.validation.ts` contains S3_ENDPOINT, S3_BUCKET, OPENAI_API_KEY
7. Prisma schema contains Document model with DocumentStatus enum, DocumentChunk model with `Unsupported("vector(1536)")` column
8. Migration SQL contains HNSW index creation
</verification>

<success_criteria>
- Prisma schema: 10 models, 10 enums, User has `documents` relation
- S3Service creates bucket on module init, uploads/downloads/deletes objects, generates presigned URLs
- File upload endpoint validates type + size via ParseFilePipe, streams to MinIO
- Text + URL ingestion endpoints create records and enqueue jobs
- Document CRUD: list (user-scoped), get, delete with S3 cleanup
- KnowledgeBaseModule registered in AppModule with document-processing queue
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-knowledge-base/02-01-SUMMARY.md`
</output>
